# -*- coding: utf-8 -*-
"""chess detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WvrM4d7C4mtVz4NNK_HXtWhklYd_CU84
"""

!pip install roboflow
!pip install ultralytics
from roboflow import Roboflow
rf = Roboflow(api_key="UjZuGrlldDcmpGbDexIN")
project = rf.workspace("tj-gabor-chess").project("board-detection-qxluh")
dataset = project.version(1).download("yolov8")

from ultralytics import YOLO
# LOAD MODEL
model = YOLO("/chess_detection.pt")  # load a pretrained model (recommended for training)

#MASKING THE IMAGE
import cv2
from google.colab.patches import cv2_imshow
testimage = "/content/board-detection-1/test/images/17_jpeg_jpg.rf.325da93dd1aac3553d06ef3102596a57.jpg"
image = cv2.imread(testimage)
image = cv2.resize(image,(640,640))
cv2.imwrite('testimage.jpeg', image)

# PREDICT WITH MODEL AND PLOT
results = model('/content/testimage.jpeg')  # predict on an image
res_plotted = results[0].plot()
cv2_imshow(res_plotted)

#PLACE MASK OVER IMAGE
import numpy as np
import cv2
import math
masks = result.masks.masks[0]
print(len(image))
maskedimage = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
maskedimage = cv2.GaussianBlur(maskedimage,(3,3),0)
print(len(masks))
for i in range(len(masks)):
  for j in range(len(masks[0])):
    if masks[i][j] == 0:
      maskedimage[i][j] = 0
    else:
      maskedimage[i][j] = 255

#CANNY DETECTION ON MASK TO OBTAIN CLEAN BORDERS
edged = cv2.Canny(maskedimage, 30, 200)
cv2_imshow(edged)

#HOUGH LINES DETECTION TO OBTAIN LINEAR APPROXIMATIONS OF EACH EDGE
cdst = cv2.cvtColor(edged, cv2.COLOR_GRAY2BGR)
cdstP = np.copy(cdst)
linesP = cv2.HoughLinesP(edged, 1, np.pi / 180, 60, None, 70, 20)
if linesP is not None:
    for i in range(0, len(linesP)):
        l = linesP[i][0]
        cv2.line(cdstP, (l[0], l[1]), (l[2], l[3]), (0,0,255), 3, cv2.LINE_AA)
cv2_imshow(cdstP)

#CALCULATE INTERSECTIONS
def equation(coords):
    """
    Converts line equation from cartesian coordinates to mx+b
    Returns:
        m: slope of the line
           For horizontal line: m = 0
           For vertical line: m = np.nan
        b: intercept when x=0
    """
    x1 = coords[0]
    y1 = coords[1]
    x2 = coords[2]
    y2 = coords[3]
    m = (y2-y1)/(x2-x1)
    b = y1 - m * x1
    if math.isinf(m):
      return int(x1), None
    else:
      return m, b
def intersection(m1: float, b1: float, m2: float, b2: float):
    # Consider y to be equal and solve for x
    # Solve:
    #   m1 * x + b1 = m2 * x + b2
    if m1 == m2:
      return
    if b1!=None and b2!=None:
      x = (b2 - b1) / (m1 - m2)
      # Use the value of x to calculate y
      y = m1 * x + b1
    elif b1==None:
      x = m1
      y = m2*x + b2
    elif b2==None:
      x = m2
      y = m1*x + b1
    return int(x), int(y)

def group_lines(lineqs):
  slopedict = dict()
  lines = []
  for l in lineqs:
    m,b = l
    check = False
    conflict = None

    for elem in slopedict:
      if abs(elem - m) < 0.5 or (abs(elem-m)<3 and b==None):
        check = True
        conflict = elem
    if not(check):
      slopedict[m] = l
      lines.append(l)
    else:
      otherm, otherb = slopedict[conflict]
      if b!= None and otherb-b>5:
        slopedict[m] = l
        lines.append(l)
  return lines

def plot_lines(lines):
  lineimg = np.zeros((640, 640, 3), dtype = np.uint8)
  for l in lines:
    m,b = l
    if b!=None:
      p1 = (0,int(b))
      p2 = (640,int(640*m+b))
    else:
      p1 = (int(m), 0)
      p2 = (int(m), 640)
    lineimg = cv2.line(lineimg, p1, p2, (0,0,255), 1, cv2.LINE_AA)
  cv2_imshow(lineimg)
  return lineimg

def intersect_lines (slopes):
  points = []
  for s1 in slopes:
    for s2 in slopes:
      if s1!=s2:
        m1,b1 = s1
        m2,b2 = s2
        points.append(intersection(m1,b1,m2,b2))
  finalpoints = []
  for p in points:
    if p!=None:
      x,y = p
      if x>0 and y>0 and x<640 and y<640 and p not in finalpoints:
        finalpoints.append(p)
  return finalpoints

def plot_edges(lines: np.array, image_shape: tuple):
    """
    Returns the intersection points that lie on the image
    for all combinations of the lines
    """
    width, height = image_shape
    if len(lines.shape) == 3 and \
            lines.shape[1] == 1 and lines.shape[2] == 2:
        lines = np.squeeze(lines)
    lines_count = len(lines)
    intersect_pts = []
    lineqs = []
    for i in range(lines_count):
      m,b = equation(lines[i][0])
      lineqs.append((m,b))
    print(lineqs)
    slopes = group_lines(lineqs)
    slopes.append((0.0, 452.0))
    print(slopes)
    points = intersect_lines(slopes)
    return plot_lines(slopes), points

def angle_of_vectors(a,b,c,d):

     dotProduct = a*c + b*d
         # for three dimensional simply add dotProduct = a*c + b*d  + e*f
     modOfVector1 = math.sqrt( a*a + b*b)*math.sqrt(c*c + d*d)
         # for three dimensional simply add modOfVector = math.sqrt( a*a + b*b + e*e)*math.sqrt(c*c + d*d +f*f)
     angle = dotProduct/modOfVector1
     angleInDegree = math.degrees(math.acos(angle))
     return (angleInDegree)

def sortpoints(points):
  center = (320,320)
  angles = []
  for p in points:
    if p!=None:
      x,y = p
      angle = angle_of_vectors(-320,0,x-320,320-y)
      if y>320:
        angle = 360-angle
      angles.append(angle)
  indices = np.argsort(angles)
  finalpoints = []
  for i in indices:
    finalpoints.append(points[i])
  return finalpoints

lineimg,points = plot_edges (linesP, (len(edged[0]), len(edged)))
points = sortpoints(points)

one = points[0]
two = points[1]
three = points[2]
four = points[3]
plot = image.copy()
plot = cv2.circle(plot, one, radius=5, color=(0, 255, 0), thickness=-1)
plot = cv2.circle(plot, two, radius=5, color=(0, 255, 0), thickness=-1)
plot = cv2.circle(plot, three, radius=5, color=(0, 255, 0), thickness=-1)
plot = cv2.circle(plot, four, radius=5, color=(0, 255, 0), thickness=-1)
cv2_imshow(plot)

#WARP IMAGE
rect = np.array(((one[0], one[1]), (two[0], two[1]), (three[0], three[1]),
(four[0], four[1])), dtype="float32")
width = 640
height = 640
dst = np.array([[0,0], [width,0], [width,height], [0,height]],dtype="float32")
M = cv2.getPerspectiveTransform(rect,dst)
warped_img = cv2.warpPerspective(image, M, (width, height))
cv2_imshow(warped_img)

#DIVIDE CELLS
plottedpoints = warped_img.copy()
step = 640/8
for i in range(9):
  for j in range(9):
    plottedpoints = cv2.circle(plottedpoints, (+int(i*step), +int(j*step)), radius=8, color=(255, 0, 0), thickness=-1)
cv2_imshow(plottedpoints)
print(len(plottedpoints))

rowcols = [int(i*step) for i in range(9)]
rowcols[0] = 0
rowcols[8] = 640

model = YOLO("/content/detect_best100.pt")  # load a custom model
results = model('/content/testimage.jpeg')

# PREDICT WITH MODEL
result = results[0]
res_plotted = result.plot()
res_plotted = cv2.resize(res_plotted, (640,640))
cv2_imshow(res_plotted)

names = results[0].names
boxes = results[0].boxes.boxes.cpu().numpy()

boxcoords = dict()
H = cv2.getPerspectiveTransform(rect, dst)
def transformboxes (boxes):
  newboxes = []
  boxplot = warped_img.copy()
  for box in boxes:
    pts = np.array(
        [[ [(box[0]+box[2])/2, box[3]] ]]
        )
    newbox = cv2.perspectiveTransform(pts, H)
    newbox = [int(newbox[0][0][0]), int(newbox[0][0][1])]
    newboxes.append(newbox)
    boxplot = cv2.circle(boxplot, tuple(newbox), radius=3, color=(255, 0, 0), thickness=-1)
    if newbox[0]<640 and newbox[1]<640 and newbox[0]>0 and newbox[1]>0:
      boxcoords[tuple(newbox)] = box[5]
  cv2_imshow(boxplot)
  return newboxes
newboxes = transformboxes(boxes)

board = [['_','_','_','_','_','_','_','_'],['_','_','_','_','_','_','_','_'],['_','_','_','_','_','_','_','_'],['_','_','_','_','_','_','_','_'],['_','_','_','_','_','_','_','_'],['_','_','_','_','_','_','_','_'],['_','_','_','_','_','_','_','_'],['_','_','_','_','_','_','_','_']]
piecesdict = {0:'♝', 1:'♗', 2:'♚', 3:'♔', 4:'♞', 5:'♘', 6:'♟', 7:'♙', 8:'♛', 9:'♕', 10:'♜', 11:'♖'}
piecesdict = {0:'b', 1:'B', 2:'k', 3:'K', 4:'n', 5:'N', 6:'p', 7:'P', 8:'q', 9:'Q', 10:'r', 11:'R'}
for i in boxcoords:
  x,y = i
  yindex = 0
  while(y>rowcols[yindex]):
    yindex+=1
  yindex-=1
  xindex = 0
  while(x>rowcols[xindex]):
    xindex+=1
  xindex-=1
  board[yindex][xindex] = piecesdict[boxcoords[i]]

def prettyprint(board):
  for row in board:
    s = ' '.join(row)
    print(s)

prettyprint(board)

print(len('r__k____bp______n_b_______k_______B_____P_N______B_B___P__Q__R__'))

#!pip install face_recognition
import cv2
import face_recognition
from google.colab.patches import cv2_imshow
image = face_recognition.load_image_file("/content/336585188_936205000851001_3495684285724323027_n.png")
face_locations = face_recognition.face_locations(image)
#(top, right, bottom, left)
image = cv2.imread("/content/336585188_936205000851001_3495684285724323027_n.png")
for face_location in face_locations:
  image = cv2.rectangle(image, (face_location[3], face_location[0]), (face_location[1], face_location[2]), (255, 0, 0), 2)
cv2_imshow(image)

print(len(face_locations))

